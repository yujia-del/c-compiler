# Compiler

## 项目要求

*编译器演示程序，可将C 语言测试程序编译为目标代码——汇编程序，用汇编器转换为二进制程序后运行无误。*

1. 基本要求

    * 数据类型：int

    * 语句：注释，声明，赋值，循环（while和for）判断（if），输入输出

    * 算术运算：+，-，*，/，%，^

    * 关系运算：==，>，<，>=，<=，!=

    * 逻辑运算：&&（与），||（或），!（非）

2. 完成功能

    |功能|分值|
    |:-:|:--:|
    |词法分析|6分|
    |语法分析|8分|
    |类型检查|4分|
    |代码优化|1分|
    |汇编程序|3分|

3. 提交内容

    * 编译器源程序文本，包括Lex、Yacc 等程序和C/C++程序。

    * 实验报告（3 分）

4. 检查作业内容及时间

    a) 词法分析结果（9.30-10.12）

    b) 语法分析结果-语法树（10.28-11.4）

    c) 可执行文件生成结果（12.9-12.16）

5. 加分项：

    1. 支持过程或函数调用+1.5

    2. 支持数组运算一维数组+1 多维数组+1.5

    3. 支持指针运算一维指针+1 多重指针+1.5

    4. 支持结构体+1

## 环境准备

* 操作系统：**Ubuntu LTS 18.04**，其他**GNU LINUX**发行版，或**MacOS**

* 依赖包：
  * Linux: `nasm`，`flex`，`bison`，`gcc-multilib`，`build-essential`
  * MacOS: `nasm`，`flex`，`bison`，`gcc`（可通过Homebrew安装：`brew install nasm flex bison`）

## 如何运行

### 构建步骤

最简单的完整构建方式是执行以下命令：

```bash
# 在代码根目录执行
make grammar && make && make build
```

这个命令序列将：
1. 生成语法分析器文件
2. 编译项目生成parser可执行文件
3. 创建build目录并复制所有必要文件

### 清理构建产物

如果需要清理所有构建产物，可以使用以下命令：
make clean


执行`make clean`会删除以下内容：
- 语法分析文件夹 (`./output/yufa/`)：包含bison和flex生成的文件
- 所有目标文件 (.o文件)
- 可执行文件 (`parser`)
- 构建文件夹 (`build/`)：包含测试程序和IO文件
- 汇编IO对象文件 (`common/util/io/asm_io.o`)

### 运行编译器

构建完成后，可以在build目录中运行编译器：

```bash
cd build
./parser test/swap.c  # 默认行为
./parser -i test/swap.c  # 生成中间代码和语法树
```

构建成功后，build目录将包含：
- parser可执行文件
- 所有测试文件（.c）
- io目录（包含汇编I/O文件）
- 从example目录复制的Makefile（用于编译测试程序）

## 文件目录说明

1. `common`目录

    包含了主要类文件，目录下的trees.h文件包含了与语法树相关的类，外部使用时只需要包含该头文件即可包含所有相关头文件

    * `symbol`子目录

        包含了symbol符号表类、FuncSymbol符号表类的源文件

    * `trees`子目录

        包含了抽象语法树（AST）相关类源文件
    
    * `util`子目录

        包含主要工具类，中间代码类、汇编代码生成类、io汇编源文件

2. `test`目录

    包含测试用的C语言源文件（如swap.c、array.c等）及其生成的中间文件（.ir、.ast等）

3. `build`目录

    用于存放编译后的可执行文件和测试环境

4. `example`目录

    包含一个Makefile，用于在build目录中编译和运行测试程序，支持将C语言测试程序编译为汇编并执行

5. `output`目录

    存放由flex和bison生成的语法分析器相关文件

6. `Makefile`，项目构建文件（支持Linux和MacOS）

## 相关代码说明

1. `./common/symbol/symbol.h`中`SymbolTable`类的说明

    |类方法|返回值|参数列表|作用|参数意义|
    |:----:|:---:|:-----:|:--:|:-----:|
    |`SymbolTable`||`bool isFun`|唯一公有构造函数，创建一个空的符号表|该作用域是否为函数|
    |`createChildTable`|`SymbolTable*`|`bool isFun`|创建一个子符号表并返回（已经设置了peer指针和child指针，调用者无需负责）|该子符号表控制作用域是否为函数|
    |`addSymbol`|`int`|`string idName, symbolType idType`|尝试向当前符号表添加符号，如果存在相同符号名返回-1，成功则返回0|符号名和符号类型|
    |`findSymbol`|`symbol*`|`const string name`|在符号表中搜索符号，如果当前符号表没有搜索到则向父级符号表搜索|符号名|

2. `./common/symbol/symbol.h`中`symbol`类的说明

    请负责中间代码生成部分的程序员注意，不需要修改offset值和index值，开放给中间代码生成部分的类成员变量只有idName和idType

## 新功能说明

1. **语法树生成**：
   - 支持将源代码解析后的抽象语法树（AST）保存到文件中
   - 生成的.ast文件与输入的.c文件位于同一目录
   - 包含完整的节点结构、层次关系和节点属性信息

2. **四元式输出格式优化**：
   - 四元式表格采用固定宽度列对齐格式
   - 操作符、参数、结果等字段宽度统一设置为15个字符
   - 提高了IR文件的可读性和美观性

## 命令行参数

编译器支持以下命令行参数：
- `-i`：生成中间代码（.ir文件）和语法树（.ast文件）
- `-t`：打印抽象语法树
- `-a`：打印汇编代码
- `-d`：调试模式，打印所有信息

## 编译和运行测试程序

构建完成后，可以在build目录中使用example/Makefile编译和运行测试程序：

```bash
cd build
# 编译并运行单个测试程序
make swap  # 编译并运行swap.c

# 编译并运行所有测试程序
make all
```

每个测试程序的编译过程包括：
1. 使用parser将C代码转换为汇编代码
2. 使用nasm汇编器将汇编代码转换为目标文件
3. 使用gcc链接生成可执行文件

## 注意事项

1. 该编译器实现了C语言的一个子集，支持基本的数据类型、控制结构和运算操作
2. 构建顺序非常重要，必须先执行`make grammar`，然后执行`make`，最后执行`make build`
3. 在MacOS上运行时，确保已通过Homebrew安装了所有必要的依赖工具
4. 测试程序需要通过io目录下的汇编I/O文件来实现输入输出功能
